# -*- cperl -*-

##### General layout of the module #####
#
# Each type of transform that is supported by this module has a plain,
# unthreaded perl entry point the user calls. This entry point makes sure the
# FFTW plan exists (or makes it). Then it calls the THREADED PP function to
# actually compute the transform

# I generate code for up to 10-dimensional FFTs
my $maxrank = 10;

pp_addhdr( '
#include <fftw3.h>
' );


# available functions:
# fft{inplace,not}{inverse,forward}{real,complex}
#
# I want to be able to say $X = fft1($x); rank is required. fft() is ambiguous
# about whether threading is desired or ir a large fft is desired. Old PDL::FFTW
# did one thing, matlab does another, so I do not include this function at all




# I define up to rank-10 FFTs. This is annoyingly arbitrary, but hopefully
# should be sufficient
for my $rank (1..$maxrank)
{
  generateDefinitions($rank);
}
pp_export_nothing();

pp_addxs('', `cat compute_plan_template.xs`);
pp_addpm( {At => 'Top'}, scalar `cat FFTW3_header_include.pm` );


for my $rank (1..$maxrank)
{
  pp_addpm({At => 'Bot'}, <<EOF );
sub fft$rank { __fft_internal( "fft$rank",\@_ ); }
eval( "*PDL::fft$rank = \&fft$rank;" );

sub ifft$rank { __fft_internal( "ifft$rank", \@_ ); }
eval( "*PDL::ifft$rank = \&ifft$rank;" );

sub realfft$rank { __fft_internal( "realfft$rank", \@_ ); }
eval( "*PDL::realfft$rank = \&realfft$rank;" );

sub irealfft$rank { __fft_internal( "irealfft$rank", \@_ ); }
eval( "*PDL::irealfft$rank = \&irealfft$rank;" );
EOF

  pp_add_exported( "fft$rank", "ifft$rank", "realfft$rank", "irealfft$rank" );
}

pp_done();


sub generateDefinitions
{
  my $rank = shift;

  ################################################################################
  ####### first I generate the definitions for the simple complex-complex FFT case
  my $funcname = "__fft$rank";

  # make dimension string 'n0=2,n1,n2,n3,n4...'. The leading 2 is for the
  # (real,imag) complex pair
  my @dims = map {"n$_"} 1..$rank;
  unshift @dims, 'n0=2';
  my $dims_string = join(',', @dims);

# TODO worry about alignment

  my $code =  `cat template_complex.c`;

  my %pp_def = ( HandleBad    => 0,
                 Pars         => "in($dims_string); [o]out($dims_string);",
                 GenericTypes => [F,D],
                 Code         => $code,
                 OtherPars    => 'IV plan', # comes not from the user, but
                                            # from the pre-fft code

                 # this is a private function so I don't want to create
                 # user-visible documentation or exports
                 Doc          => undef,
                 PMFunc       => ''
               );
  pp_def( $funcname, %pp_def );



  ##################################################################################
  ####### now I generate the definitions for the real-complex and complex-real cases
  my @dims_real    = @dims;
  my @dims_complex = @dims;

  shift @dims_real; # get rid of the (real,imag) dimension for the real numbers
  $dims_complex[1] = 'nhalf'; # first complex dim is real->dim(0)/2+1
  $pp_def{RedoDimsCode} = '$SIZE(nhalf) = (int)( $PDL(real)->dims[0]/2 ) + 1;';
  my $dims_real_string    = join(',', @dims_real);
  my $dims_complex_string = join(',', @dims_complex);

  my $code_real          = `cat template_real.c`;
  my $code_real_forward  = $code_real;
  my $code_real_backward = $code_real;

  $code_real_forward  =~ s/INVERSE/0/g;
  $code_real_backward =~ s/INVERSE/1/g;

  # forward
  $pp_def{Pars} = "real($dims_real_string); [o]complex($dims_complex_string);";
  $pp_def{Code} = $code_real_forward;
  pp_def( "__realfft$rank", %pp_def );

  # backward
  $pp_def{Pars} = "complex($dims_complex_string); [o]real($dims_real_string);";
  $pp_def{Code} = $code_real_backward;
  pp_def( "__irealfft$rank", %pp_def );
}
